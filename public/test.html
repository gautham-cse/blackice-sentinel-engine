<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BlackIce Signaling Protocol</title>

  <style>
    body {
  font-family: Arial, sans-serif;
  padding: 20px;
}
#messages {
  border: 1px solid #ccc;
  height: 200px;
  overflow-y: scroll;
  padding: 10px;
  margin-bottom: 10px;
}
input, button {
  padding: 10px;
  margin: 5px 0;
  width: 100%;
}

  </style>
</head>
<body>
<h2>BSP Audio Test</h2>

<label>User ID:</label>
<input type="text" id="userID" placeholder="alice or bob">
<label>JWT Token:</label>
<input type="text" id="jwtToken" placeholder="Paste JWT here">
<button id="connectBtn">Connect to Signaling</button>

<h3>Active Users</h3>
<ul id="activeUsers"></ul>

<div id="messages"></div>

<label>Call User ID:</label>
<input type="text" id="remoteUser" placeholder="Remote userID">
<button id="callBtn">Start Call</button>

<audio id="remoteAudio" autoplay></audio>

<script src="script.js"></script>
</body>
</html>


<script>
  let ws;
  let peerConnection;
  let localStream;

  // Logging helper
  function log(msg) {
    const messages = document.getElementById("messages");
    messages.innerHTML += msg + "<br>";
    messages.scrollTop = messages.scrollHeight;
  }

  // Generate a random userID if empty
  function generateUserID() {
    return "user" + Math.floor(Math.random() * 10000);
  }

  // Connect to signaling server
  async function connect() {
    let userID = document.getElementById("userID").value;
    if (!userID) {
      userID = generateUserID();
      document.getElementById("userID").value = userID;
    }

    // Auto-fetch JWT from server
    const res = await fetch(`/get_jwt?user=${userID}`);
    const token = await res.text();

    ws = new WebSocket(`${location.protocol === "https:" ? "wss" : "ws"}://${location.host}/ws`);

    ws.onopen = () => {
      log(`Connected as ${userID}`);
      ws.send(JSON.stringify({ token }));
    };

    ws.onmessage = async (event) => {
      const msg = JSON.parse(event.data);
      log("Received: " + JSON.stringify(msg));

      if (msg.type === "INVITE") await startCall(false, msg.from);
      else if (msg.type === "ACCEPT") {
        const desc = new RTCSessionDescription(msg.sdp);
        await peerConnection.setRemoteDescription(desc);
      } else if (msg.type === "ICE" && peerConnection) {
        try { await peerConnection.addIceCandidate(msg.candidate); } catch(e){ console.error(e); }
      }
    };
  }

  // Fetch and display active users every 3 seconds
  async function fetchActiveUsers() {
    const res = await fetch("/active_users");
    const users = await res.json();
    const list = document.getElementById("activeUsers");
    list.innerHTML = "";

    users.forEach(u => {
      if (u === document.getElementById("userID").value) return; // skip self
      const li = document.createElement("li");
      li.textContent = u;
      li.style.cursor = "pointer";
      li.style.color = "blue";
      li.onclick = () => startCall(true, u); // auto start call when clicked
      list.appendChild(li);
    });
  }

  // Periodically refresh active users
  setInterval(fetchActiveUsers, 3000);

  // Initial fetch on load
  window.onload = () => {
    const id = generateUserID();
    document.getElementById("userID").value = id;
    fetchActiveUsers();
  };


  // Call buttons
  document.getElementById("connectBtn").onclick = connect;
  document.getElementById("callBtn").onclick = () => {
    const remoteID = document.getElementById("remoteUser").value;
    startCall(true, remoteID);
  };
</script>